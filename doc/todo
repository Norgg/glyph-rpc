done:
    move to wsgi, requests. move to params as constructor
    mapper
    transient objects
    silent server
    make_server ssl args
    carry over args to werzkeug
    form bug
    documentation
    removed prints
    split out into parts
    price checker skeleton

    refactor:
        moved to werkzeug exceptions
        change from Mapper <-> Resources
        to Router <-> Mapper <-> User Objects

    nope: mapper should only take named resources - unnamed ones can be mapped ad-hoc
        rationale: hard to do properly with linking, embedding, etc. 
    done: router should ask resources to urlify themselves?
        mapper now handles this outside router

    worker queue example

    refactoring:
        transientmapper/basemapper - transient mapper handles state transfer
        page/index - split inspection out into different bits.

    HateMethod added for safe, inlining
        safe get linked, unsafe get forms, inlines get embed

    after removing index method, use in real world demanded it back
    it's nice - you can now override methods

    renaming

remember:
    should handle http mapping by default, verbs, urls and content_type
    should be possible to use objects outside of mapper.
    http ignorant not agnostic (don't need to know http semantics to use it, but can override)

todo:
    pretty printing.

    documentation:
        under the scenes - request by request
            worked example
        glyph encoding clarifcations
            duplicate dict keys 
            hex parsing

        node/extension data types

    glyph.get(url/link/page?, options) etc?
        glyph.url(object) returns the url as a string

    
    encoding handles unknown types with callback
            callback from router turns resources into links/forms/etc?

        
    documentation:
        cookbook more examples:doing it by hand client/server.
        examples/pricechecker/ add loadbalancers, test caching, sharding version too

    in-browser control/debugging:
        content negociation: html5/json serialization? 
        porting client to javascript/ajax?
        can use werkzeug templates to make html5/bootstrap interface.


    persistent mapper:
        can't create on get unless it exists already/linked to.
        some expire, some don't ? raise an Exception to delete ?
        expiry exception in client

    glyph.get handling different content-types 
        if unhandled:
            throw result(content_type, content), decoded if text/*
        override in get(). 

    caching 

    extending behavior:
        decorators?  @inline @safe?  @expires @idempotent @content_type @accept @ssl_only @GET? @POST?  
        hypermedia: form/link/embed (get/put/delete)?
        overrides: method, content type url mapping, query arguments
            @resource <-> @property, allow ovveriding bits of methods?

    properties:
        perhaps? handle @properties and produce getters and setters (GET/PUT/DELETE)
        dont expose form, expose an embed attribute with put, get, delete methods?
        hard to do properly, what do you to do embed a link, etc ? self.foo calls __get__ ....

    versioning?
        possibly: map default to /v0/ , default takes a version arg? breaks url mapping :v
        possibly: / returns 300 if multiple versions, link header? rel=...

    collections:
        like an embed/property, but behaves with the __getitem__ calls ?
        think about interface for pagination/mapping to an infinite scroll, etc.
        inlining - behaves like a link, isn't.


    snapshoting:
        crawling an api? glyph.crawl(page) returns all links() ?
    
    routing:
        use werkzeug rules inside router

    dependencies
        requests should be optional dependency?

    glyph serialization
            maybe: break bencode, use [] for list, {} for dict 
            maybe: better terminator char doesn't appear in float, datetimes?, newlines
            maybe: stick with e for some things?
                breaks possible pretty printing ?
                ?humane content_type arg
        new data types:
            charset handling ? timezones? time periods ?
        refactoring:
            make it dict driven instead of if-chain driven


usecases/testcases
    demos:
        heroku/appengine ?
    atom pub mail server?  mail store? forum queue/broker(herp?)
        use preconditions to do transactional semantics?

    snmp? crawling
    scraper pool ?
        sharding, load balancing, caching, extending
    twitter api - last-modified embedding hack
            use embedded for all new items, links for all client is expected to have already
    examples for a talk?
    db cursors alike for collections ? pagination


ports:
    jquery plugin?
    ruby, js - object style
    cgi/php: create foo.php for each resource, use links.
    0mq transport :v websocket upgrades to get a bi-di socket :v
