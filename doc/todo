done:
    move to wsgi, requests. move to params as constructor
    mapper
    transient objects
    silent server
    make_server ssl args
    carry over args to werzkeug
    form bug
    documentation
    removed prints
    split out into parts
    price checker skeleton

    refactor:
        moved to werkzeug exceptions
        change from Mapper <-> Resources
        to Router <-> Mapper <-> User Objects

    nope: mapper should only take named resources - unnamed ones can be mapped ad-hoc
        rationale: hard to do properly with linking, embedding, etc. 
    done: router should ask resources to urlify themselves?
        mapper now handles this outside router

    worker queue example

    refactoring:
        transientmapper/basemapper - transient mapper handles state transfer
        page/index - split inspection out into different bits.

remember:
    should handle http mapping by default, verbs, urls and content_type
    should be possible to use objects outside of mapper.
    http ignorant not agnostic (don't need to know http semantics to use it, but can override)

todo:
    hate.get(url/link/page?, options) etc?
        hate.url(object) returns the url as a string

    
    method mappers, decorators
        attach a method mapper to func.__hate__, and pass on request to it
            default method mapping does POST only
        @safe, @cache change __hate__ if exists.

        caching/safe methods: 
            return links in index, not forms. add caching headers?
            
        inlining: 
            return in index instead of gettting, still behaves like a link, but with data attached.
        
    documentation:
        cookbook more examples:doing it by hand client/server.
        examples/pricechecker/ add loadbalancers, test caching, sharding version too

    in-browser control/debugging:
        content negociation: html5/json serialization? 
        porting client to javascript/ajax?
        can use werkzeug templates to make html5/bootstrap interface.

    hyperglyph handles unknown types with callback
            callback from router turns resources into links/forms/etc?

    persistent mapper:
        can't create on get unless it exists already/linked to.
        some expire, some don't ? raise an Exception to delete ?
        expiry exception in client

    hate.get handling different content-types 
        if unhandled:
            throw result(content_type, content), decoded if text/*
        override in get(). 

    extending behavior:
        decorators?
            @inline @safe? 
            @expires @idempotent @content_type @accept @ssl_only
            @GET? @POST?  
            how about @foo attaches a __hate__ methodmappper to the method, and sets the details.
            in dispatch, if method has a mapper, call it
            knowing when to link and to form...

        hypermedia:
            form/link/embed (get/put/delete)?

        overrides:
            method, content type
            url mapping, query arguments
            @resource <-> @property, allow ovveriding bits of methods?

    properties:
        perhaps? handle @properties and produce getters and setters (GET/PUT/DELETE)
        dont expose form, expose an embed attribute with put, get, delete methods?
        hard to do properly, what do you to do embed a link, etc ? self.foo calls __get__ ....

    versioning?
        possibly: map default to /v0/ , default takes a version arg? breaks url mapping :v
        possibly: / returns 300 if multiple versions, link header? rel=...

    collections:
        like an embed/property, but behaves with the __getitem__ calls ?
        think about interface for pagination/mapping to an infinite scroll, etc.
        inlining - behaves like a link, isn't.


    snapshoting:
        crawling an api? hate.crawl(page) returns all links() ?
    
    routing:
        use werkzeug rules inside router

    dependencies
        requests should be optional dependency?

    hyperglyph serialization
            maybe: break bencode, use [] for list, {} for dict 
            maybe: better terminator char doesn't appear in float, datetimes?, newlines
            maybe: stick with e for some things?
                breaks possible pretty printing ?
                ?humane content_type arg
        new data types:
            charset handling ? timezones? time periods ?

usecases/testcases
    demos:
        heroku/appengine ?
    atom pub mail server?  mail store? forum queue/broker(herp?)
        use preconditions to do transactional semantics?

    snmp? crawling
    scraper pool ?
        sharding, load balancing, caching, extending
    twitter api - last-modified embedding hack
            use embedded for all new items, links for all client is expected to have already
    examples for a talk?
    db cursors alike for collections ? pagination


ports:
    jquery plugin?
    ruby, js - object style
    cgi/php: create foo.php for each resource, use links.
    0mq transport :v websocket upgrades to get a bi-di socket :v
